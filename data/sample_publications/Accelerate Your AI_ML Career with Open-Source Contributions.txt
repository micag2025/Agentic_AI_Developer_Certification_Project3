Accelerate Your AI/ML Career with Open-Source Contributions

Id:
fUTy90FWorvg

Username:
3rdson

License:
none

Publication_description:
Whether you are a beginner eager to build your portfolio or a seasoned pro looking to collaborate on meaningful projects, open-source AI/ML offers endless opportunities to learn, grow, and make an impact.

In this article, we will introduce you to curated open-source projects; from emerging frameworks like Swarmauri to industry staples like PyTorch and Hugging Face. You will learn how to contribute effectively, avoid common pitfalls, and turn your code into a career-building asset. But first, let‚Äôs tackle the basics.

## What Are Open Source Projects?

Open-source projects are projects whose source code is publicly available for anyone to view, use, modify, and contribute to. These projects are usually maintained by a community of developers who collaborate to improve the software/framework/library, fix bugs, add new features, and ensure its overall stability.

In Al/ML, open-source projects play a huge role in innovation. Many of the tools and frameworks we use daily, like TensorFlow, PyTorch, LangChain, Scikit-Learn, etc., are open source, meaning anyone can contribute to their development.

## Why Should You Contribute to Open-Source Projects?

![Top-5-Reasons-to-Contribute-to-Open-Source-Project.png](Top-5-Reasons-to-Contribute-to-Open-Source-Project.png)

Contributing to open-source projects is one of the most rewarding ways to grow as a developer, data scientist, or AI/ML professional. Whether you're just starting or have years of experience, getting involved in open source offers a unique set of benefits that can help you build your skills, expand your network, and elevate your career. Here‚Äôs why you should consider contributing:

1. **Build Real-World Experience**

Open-source projects provide a platform to work on real-world problems and cutting-edge technologies. Unlike personal projects or coursework, contributing to open source exposes you to production-level code, collaborative workflows, and industry-standard tools. This hands-on experience is invaluable and can set you apart in the job market.

2. **Sharpen Your Technical Skills**

Whether it‚Äôs debugging, writing documentation, or optimizing algorithms, open-source contributions allow you to hone your technical skills in a practical setting. You will also get to work with tools and frameworks that are widely used in the industry, such as TensorFlow, PyTorch, or Hugging Face, giving you a competitive edge. From my personal experience, you will learn Git and GitHub very well when you start contributing to open source. I learnt Git and GitHub the best when contributing to open-source projects

3. **Showcase Your Expertise**

Your contributions to open-source projects are public and visible to everyone. This means you can showcase your work on platforms like GitHub, LinkedIn, or your portfolio. Potential employers often look at open-source contributions as proof of your skills, initiative, and ability to collaborate with others.

4. **Learn from the Best**

Open-source projects are often maintained by some of the brightest minds in the field. By contributing, you get the opportunity to learn from experienced developers, receive feedback on your code, and understand best practices in software development and machine learning.

5. **Give Back to the Community**

Many of the tools and frameworks we use daily, like Scikit-learn, Jupyter Notebooks, or LangChain, are all open source. Contributing to these projects is a way to give back to the community that has built the tools you rely on. It‚Äôs a chance to support innovation and make these resources better for everyone.

6. **Expand Your Network**

Open-source communities are global and diverse. By contributing, you will connect with like-minded individuals, collaborate with professionals from different backgrounds, and build relationships that can lead to mentorship, job opportunities, or even lifelong friendships.

7. **Boost Your Confidence**

Seeing your code merged into a popular project or receiving positive feedback from maintainers can be incredibly motivating. It‚Äôs a tangible way to measure your progress and gain confidence in your abilities as a developer or data scientist.

8. **Stay Ahead of the Curve**

Open-source projects are often at the forefront of innovation. By contributing, you will stay updated on the latest trends, tools, and techniques in AI/ML. This knowledge can help you stay relevant in a fast-evolving field.

9. **It‚Äôs Beginner-Friendly**

You don‚Äôt need to be an expert to contribute to open source. Many projects have beginner-friendly issues labelled as `good-first-issue` or `help-wanted`. These are great starting points for newcomers to get their feet wet and gradually build their confidence.

10. **Make an Impact**

Your contributions, no matter how small, can have a significant impact. Whether it‚Äôs fixing a bug, improving documentation, or adding a new feature, your work can help thousands of users and developers around the world.

:::info{title="NOTE"}
If you already have an open-source project in mind and just want to learn how to contribute effectively, skip to the end of the article. Otherwise, stick around as we‚Äôve got plenty of great options to explore!
:::

---

In this article, we will be categorizing these open-source projects based on their focus areas, making it easier. for you to find the ones that match your interests and skill level. We will cover a mix of well-established, stable projects and emerging projects that are worth keeping an eye on. This way, whether you're looking for something reliable to contribute to or want to get involved in the next big thing, you will have plenty of options to choose from.
Let's jump right into it

![1729504471981.png](1729504471981.png)

---

## Core Frameworks & Libraries

1. **PyTorch**
   PyTorch is a flexible deep learning framework developed by Meta AI in **2016**, which is renowned for its dynamic computation graph and Python-first design. It dominates research workflows for tasks like computer vision, NLP, and reinforcement learning.  
   üîó [GitHub](https://github.com/pytorch/pytorch) | [Docs](https://pytorch.org/docs/stable/index.html)

2. **TensorFlow**
   TensorFlow is Google‚Äôs flagship machine learning framework which was released in **2015** and optimized for production-grade deployments. TensorFlow powers industrial-scale AI applications.  
   üîó [GitHub](https://github.com/tensorflow/tensorflow) | [Docs](https://www.tensorflow.org/)

3. **Scikit-Learn**
   This is the go-to Python library for classical/traditional machine learning (_e.g., regression, clustering, SVMs_). Released in **2007**, it offers simple APIs for data preprocessing, model training, and evaluation.
   üîó [GitHub](https://github.com/scikit-learn/scikit-learn) | [Docs](https://scikit-learn.org/stable/)

4. **JAX**
   Jax is a high-performance numerical computing library from Google (**2018**), combining NumPy-like syntax with automatic differentiation and GPU/TPU acceleration. Key for cutting-edge research in physics, optimization, and ML.  
   üîó [GitHub](https://github.com/google/jax) | [Docs](https://jax.readthedocs.io/)

5. **XGBoost**
   XGBoost is a scalable gradient-boosting library (**2014**) for structured/tabular data. It dominates Kaggle competitions and enterprise ML pipelines with its speed, accuracy, and support for distributed training.  
   üîó [GitHub](https://github.com/dmlc/xgboost) | [Docs](https://xgboost.readthedocs.io/en/stable/)

6. **MLflow**
   A platform for managing the ML lifecycle (**2018**), including experiment tracking, model packaging, and deployment. Critical for MLOps and collaborative workflows.  
   üîó [GitHub](https://github.com/mlflow/mlflow) | [Docs](https://mlflow.org/docs/latest/index.html)

---

## Generative AI / Agentic AI / NLP Projects

1. **LangChain**
   This is one of the first and most popular open-source frameworks designed to simplify the development of LLM-powered applications. Developed in **2022**, it provides tools for chaining LLM calls, integrating with external data sources, and building AI-driven applications like chatbots and autonomous agents.
   üîó [GitHub](https://github.com/langchain-ai/langchain) | [Docs](https://python.langchain.com/docs/introduction/)

2. **LangGraph**
   Built on top of LangChain, this framework is designed for creating stateful, multi-agent, and graph-based workflows with LLMs. Developed in **2023**, it excels in constructing complex AI applications that require dynamic task coordination.
   üîó [GitHub](https://github.com/langchain-ai/langgraph) | [Docs](https://langchain-ai.github.io/langgraph/)

3. **CrewAI**
   An open-source framework for building and managing multi-agent AI workflows, CrewAI enables developers to design teams of AI agents that collaborate efficiently. Developed in **2023**, it is ideal for applications that benefit from role-based, coordinated task execution.
   üîó [GitHub](https://github.com/joaomdmoura/crewai) | [Docs](https://docs.crewai.com/introduction)

4. **LlamaIndex**
   This data framework helps LLMs connect with external data sources by providing tools for indexing, retrieving, and querying information. Developed in **2022**, it streamlines the creation of knowledge-driven AI applications.
   üîó [GitHub](https://github.com/jerryjliu/llama_index) | [Docs](https://docs.llamaindex.ai/en/stable/)

5. **Swarmauri**
   Swarmauri is still in its early stages as an open-source tool for building, testing, and deploying AI-powered applications and agents. With a low adoption rate so far, it‚Äôs a great time to contribute and help shape its future. Swarmauri was first released in 2024.
   üîó [GitHub](https://github.com/swarmauri/swarmauri-sdk) | [Docs](https://docs.swarmauri.com/index.html)

6. **Pydantic AI**
   Developed by the creators of Pydantic, Pydantic AI is a Python-based framework designed to simplify the development of production-grade applications powered by Generative AI. Released in 2024, it provides robust tools for building, validating, and deploying AI agents, ensuring reliability and scalability in real-world applications. While still in its early stages, Pydantic AI is rapidly gaining traction for its focus on developer productivity and seamless integration with existing AI workflows.
   üîó [GitHub](https://github.com/pydantic/pydantic-ai) | [Docs](https://ai.pydantic.dev/)

7. **AgentGPT**
   An emerging framework that empowers developers to create fully autonomous agents capable of multi-step reasoning and task execution. Released in **2023**, AgentGPT is gaining attention for its simplicity and robust design in building interactive AI systems.
   üîó [GitHub](https://github.com/reworkd/AgentGPT) | [Docs](https://docs.reworkd.ai/introduction)

8. **SmolAgents**
   A lightweight, modular agent framework from HuggingFace, SmolAgents is designed for rapid prototyping and deployment of specialized AI agents. Developed in **2024**, it offers an intuitive API and seamless integration with HuggingFace‚Äôs ecosystem.
   üîó [GitHub](https://github.com/huggingface/smolagents) | [Docs](https://huggingface.co/docs/smolagents)

9. **OpenAGI**
   An ambitious open-source platform aiming to push toward Artificial General Intelligence (AGI) by integrating LLMs with domain-specific expert models. Developed in **2023**, OpenAGI leverages reinforcement learning from task feedback to tackle complex, multi-step real-world tasks.
   üîó [GitHub](https://github.com/agiresearch/OpenAGI)

10. **Ollama**
    This is an open-source tool that allows you to download and run large language models locally on your computer. Developed to optimize both performance and data privacy, Ollama provides a simple, user-friendly interface for managing multiple LLMs on your hardware. By eliminating the need for cloud-based processing, it offers faster response times and greater control over model configurations, making it an excellent choice for developers and researchers looking to experiment with and deploy AI models locally.
    üîó [GitHub](https://github.com/ollama/ollama)

11. **HuggingFace Transformers**
    This is an open-source Python library that simplifies working with transformer-based models across a wide range of tasks, from natural language processing to audio and video processing. It provides seamless access to a vast collection of pre-trained models via the Hugging Face Model Hub, making it the go-to solution if you want to quickly implement state-of-the-art AI without building models from scratch.
    üîó [GitHub](https://github.com/huggingface/transformers) | [Docs](https://huggingface.co/docs/transformers)

12. **spaCy**
    spaCy is a fast, production-ready NLP library for Python, released in **2015**. It excels in tasks like tokenization, named entity recognition (NER), and dependency parsing, with pre-trained models for multiple languages.
    üîó [GitHub](https://github.com/explosion/spaCy) | [Docs](https://spacy.io/)

13. **NLTK (Natural Language Toolkit)**
    NLTK, released in **2001**, is a comprehensive NLP library designed for education and research. It offers tools for tokenization, stemming, lemmatization, and parsing, along with a vast collection of linguistic resources.
    üîó [GitHub](https://github.com/nltk/nltk) | [Docs](https://www.nltk.org/)

---

## Computer Vision / Image-Based Projects / Object Detection & Segmentation

1. **OpenCV (Open Source Computer Vision Library)**
   OpenCV is one of the most widely used libraries for computer vision tasks. It provides tools for image processing, object detection, facial recognition, and more. Developed in **2000**, it has become a cornerstone for both academic research and industrial applications.  
   üîó [GitHub](https://github.com/opencv/opencv) | [Docs](https://docs.opencv.org/)

2. **YOLO (You Only Look Once)**
   YOLO is a state-of-the-art real-time object detection system. Known for its speed and accuracy, YOLO has gone through several iterations, with YOLO11 being the latest version as of today. It is widely used in applications like surveillance, autonomous vehicles, and robotics.  
   üîó [GitHub](https://github.com/ultralytics/ultralytics) | [Docs](https://docs.ultralytics.com/)

3. **Stable Diffusion**
   Stable Diffusion is a generative AI model for creating high-quality images from text prompts. Released in **2022**, it has revolutionized the field of AI art and image generation. The model is open-source, allowing developers to fine-tune and deploy it for various creative and commercial applications.  
   üîó [GitHub](https://github.com/CompVis/stable-diffusion) | [Docs](https://huggingface.co/docs/diffusers/index)

4. **Detectron2**
   Developed by Facebook AI Research (FAIR), Detectron2 is a powerful framework for object detection, segmentation, and other vision tasks. It is built on PyTorch and offers pre-trained models for quick deployment. Released in **2019**, it is widely used in research and industry.  
   üîó [GitHub](https://github.com/facebookresearch/detectron2) | [Docs](https://detectron2.readthedocs.io/)

5. **MediaPipe**
   Developed by Google, MediaPipe is a framework for building multimodal (e.g., video, audio, and sensor data) applications. It includes pre-built solutions for face detection, hand tracking, pose estimation, and more. Released in **2019**, it is widely used for real-time vision applications.  
   üîó [GitHub](https://github.com/google/mediapipe) | [Docs](https://ai.google.dev/edge/mediapipe/solutions/guidehttps://ai.google.dev/edge/mediapipe/solutions/guide)

6. **MMDetection**
   MMDetection is an open-source object detection toolbox based on PyTorch. It supports a wide range of models, including Faster R-CNN, Mask R-CNN, and YOLO. Developed in **2018**, it is part of the OpenMMLab project and is widely used in academic and industrial research.  
   üîó [GitHub](https://github.com/open-mmlab/mmdetection) | [Docs](https://mmdetection.readthedocs.io/)

7. **Segment Anything Model (SAM)**
   Developed by Meta AI, SAM is a groundbreaking model for image segmentation. Released in **2023**, it can segment any object in an image with minimal input, making it highly versatile for applications in medical imaging, autonomous driving, and more.  
   üîó [GitHub](https://github.com/facebookresearch/segment-anything) | [Docs](https://segment-anything.com/)

8. **Fast.ai**
   Fast.ai is a deep learning library that simplifies training and deploying computer vision models. It includes pre-trained models and high-level APIs for tasks like image classification and object detection. Released in **2016**, it is widely used for educational purposes and rapid prototyping.  
   üîó [GitHub](https://github.com/fastai/fastai) | [Docs](https://docs.fast.ai/)

9. **OpenPose**
   OpenPose is a real-time multi-person keypoint detection library. It can detect human poses, hands, and facial keypoints in images and videos. Released in **2017**, it is widely used in applications like fitness tracking and animation.  
   üîó [GitHub](https://github.com/CMU-Perceptual-Computing-Lab/openpose) | [Docs](https://cmu-perceptual-computing-lab.github.io/openpose/web/html/doc/)

---

## MLOps & Deployment

1. **Kubeflow**  
   Kubeflow is the go-to open-source platform for deploying machine learning workflows on Kubernetes. Launched in **2017**, it simplifies scaling ML pipelines; from data preprocessing to model serving in cloud-native environments.
   üîó [GitHub](https://github.com/kubeflow/kubeflow) | [Docs](https://www.kubeflow.org/docs/)

2. **BentoML**  
   BentoML streamlines deploying ML models into production with a unified framework for packaging, serving, and monitoring. Released in **2019**, it supports all major frameworks (PyTorch, TensorFlow, etc.) and integrates seamlessly with Kubernetes, AWS Lambda, or your custom infrastructure.  
   üîó [GitHub](https://github.com/bentoml/BentoML) | [Docs](https://docs.bentoml.org/)

3. **Seldon Core**  
   Seldon Core is a production-grade platform for deploying ML models at scale. Launched in **2017**, it converts models into REST/gRPC microservices, handles A/B testing, and monitors performance. It is perfect for enterprises needing reliability and governance in their AI systems.  
   üîó [GitHub](https://github.com/SeldonIO/seldon-core) | [Docs](https://docs.seldon.io/projects/seldon-core/en/latest/)

4. **Feast**  
   Feast (Feature Store) is an open-source tool for managing and serving ML features in production. Released in **2019**, it bridges the gap between data engineering and ML teams, ensuring consistent feature pipelines for training and real-time inference.  
   üîó [GitHub](https://github.com/feast-dev/feast) | [Docs](https://docs.feast.dev/)

5. **Cortex**  
   Cortex automates deploying ML models as scalable APIs on AWS, GCP, or Azure. Launched in **2020**, it handles everything from autoscaling to monitoring, letting you focus on building models instead of infrastructure.  
   üîó [GitHub](https://github.com/cortexlabs/cortex) | [Docs](https://docs.cortexlabs.com/)

---

## Data Manipulation & Visualization

1. **Pandas**  
   Pandas is the go-to Python library for **data manipulation and analysis**. Released in **2008**, it simplifies tasks like cleaning, transforming, and analyzing structured data with its intuitive DataFrame API.  
   üîó [GitHub](https://github.com/pandas-dev/pandas) | [Docs](https://pandas.pydata.org/docs/)

2. **NumPy**  
   The backbone of numerical computing in Python, NumPy (**2006**) powers everything from data science to deep learning. Its `ndarray` object handles multi-dimensional arrays and matrices, making it essential for efficient ML workloads.  
   üîó [GitHub](https://github.com/numpy/numpy) | [Docs](https://numpy.org/doc/)

3. **Matplotlib**  
   The granddaddy of Python visualization (**2003**), Matplotlib turns raw data into publication-quality plots. Pair it with Pandas for quick exploratory data analysis (EDA).  
   üîó [GitHub](https://github.com/matplotlib/matplotlib) | [Docs](https://matplotlib.org/)

4. **Seaborn**  
   Seaborn (**2012**) supercharges Matplotlib with sleek statistical visualizations. Perfect for heatmaps, distribution plots, and correlation matrices.  
   üîó [GitHub](https://github.com/mwaskom/seaborn) | [Docs](https://seaborn.pydata.org/)

5. **Plotly**  
   Plotly (**2013**) creates **interactive, web-ready visualizations**. Build dashboards, 3D plots, or geographic maps, all with Python or JavaScript.  
   üîó [GitHub](https://github.com/plotly/plotly.py) | [Docs](https://plotly.com/python/)

---

## Step-by-Step Guide to Contributing to Open-Source Projects

![PHOTO-2025-03-15-11-11-16.jpg](PHOTO-2025-03-15-11-11-16.jpg)
Contributing to open-source projects might feel intimidating at first, especially when you‚Äôre staring at a massive codebase. But don‚Äôt worry. Once you break it down into small steps, it becomes surprisingly straightforward. Let‚Äôs walk through the process together.

---

### Step 1: Find the Project‚Äôs GitHub Page

Start by navigating to the project‚Äôs GitHub repository. For example, if you want to contribute to **Hugging Face Transformers**, search for ‚ÄúHugging Face Transformers GitHub‚Äù or use the direct link from their documentation.

üîç _Pro tip_: Most projects link their GitHub repo in their official documentation or website footer. Look for a tiny üêô or "View on GitHub" button!

---

### Step 2: Read the `CONTRIBUTING.md` File

Every well-maintained project has a `CONTRIBUTING.md` file (sometimes named `CONTRIBUTORS.md` or `GUIDELINES.md`). This document is your cheat sheet because it explains _exactly_ how to contribute, including:

- **Setup instructions** (e.g., how to install dependencies).
- **Coding standards** (e.g., linting rules or testing requirements).
- **Workflow guidelines** (e.g., how to submit a pull request).

For example, here‚Äôs what you will see in **Swarmauri‚Äôs** `CONTRIBUTING.md`:

```markdown
How to Contribute

1. Fork the Repository:

- Navigate to the repository and fork it to your GitHub account.

2. Star and Watch:

- Star the repo and watch for updates to stay informed.

3. Clone Your Fork:

- Clone your fork to your local machine:
  git clone https://github.com/your-username/swarmauri-sdk.git

4. Create a New Branch:

- Create a feature branch to work on:
  git checkout -b feature/your-feature-name

5. Make Changes:

- Implement your changes. Write meaningful and clear commit messages.
- Stage and commit your changes:
  git add .
  git commit -m "Add a meaningful commit message"

6. Push to Your Fork:

- Push your branch to your fork:
  git push origin feature/your-feature-name

7. Write Tests:

- Ensure each new feature has an associated test file.
- Tests should cover:
  a. Component Type: Verify the component is of the expected type.
  b. Resource Handling: Validate inputs/outputs and dependencies.
  c. Serialization: Ensure data is properly serialized and deserialized.
  d. Access Method: Test component accessibility within the system.
  e. Functionality: Confirm the feature meets the project requirements.

8. Create a Pull Request:

- Once your changes are ready, create a pull request (PR) to merge your branch into the main repository.
- Provide a detailed description, link to related issues, and request a review.
```

:::warning
_Don‚Äôt skip this step!_ Maintainers _love_ contributors who follow their guidelines. Ignoring the rules could lead to your Pull Request (PR) being rejected, even if your code is perfect.  
:::

---

:::tip{title="Pro Tip"}

**What If There‚Äôs No `CONTRIBUTING.md`?**  
Don‚Äôt panic. Many projects are still evolving, and documentation might lag. Here‚Äôs how to navigate this:

1. **Check the `Issues` Tab**:
   Look for labels like `good-first-issue` or `help-wanted` as these are golden tickets for newcomers. For instance, **AgentGPT** doesn‚Äôt have a `CONTRIBUTING.md` yet, but its GitHub Issues are filled with tagged tasks, perfect for newcomers.

2. **Join the Conversation**:
   Head to the project‚Äôs **Discussions**, **Slack**, or **Discord** (linked in the repo‚Äôs ‚ÄúAbout‚Äù section). A quick ‚ÄúHow can I help?‚Äù post often gets maintainers excited to guide you.

3. **Learn from Others**:
   Browse **recent pull requests** to see how contributors structured their code, wrote commit messages, or addressed feedback. Mimic their workflow to avoid rookie mistakes.

If all of the above fails, open an issue asking, ‚ÄúHow can I contribute?‚Äù Most maintainers will gladly point you to the right direction. üëç

:::

---

### Step 3: Fork, Setup, and Submit Your First PR

Time to roll up your sleeves. Let‚Äôs turn theory into action with a step-by-step walkthrough.

---

**1. Fork the Repository**

Forking creates your copy of the project on GitHub, allowing you to experiment without affecting the original codebase.

**How to do it**:

- Click the **‚ÄúFork‚Äù** button at the top-right of the project‚Äôs GitHub page.  
  ![PHOTO-2025-03-18-13-39-09.jpg](PHOTO-2025-03-18-13-39-09.jpg)

---

**2. Clone Your Fork Locally**

Clone the forked repo to your machine to start coding:  
Open your terminal/command line and write the command below

```bash
git clone https://github.com/your-username/project-name.git
cd project-name
```

_Heads up_: Use the **SSH URL** if you‚Äôve set up SSH keys for GitHub (fewer password prompts).

---

**3. Set Up the Development Environment**

Most projects require dependencies and configurations. Check the `CONTRIBUTING.md` or `README.md` for setup instructions.

**Typical workflow**:

```bash
# Create a virtual environment (avoid dependency conflicts)
python -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Run tests to confirm everything works
pytest tests/
```

üí° _Pro Tip_: If the project uses Docker, run `docker-compose up` for a hassle-free setup.

---

**4. Create a Feature Branch**

Never work directly on the `main` branch. Create a new branch for your changes:

```bash
git checkout -b fix/typo-in-docs
```

üö® _Fun fact_: Branch names like `add-spaceship-emojis` are more memorable (and fun) than `patch-1`.

---

**5. Make Changes & Commit**

Now, code away üöÄ. Once done, commit your changes with a **clear, concise message**:

```bash
git add .
git commit -m "Fix typo in quickstart guide"
```

üí• _Golden rule_: One logical change per commit. No ‚Äúfixed stuff‚Äù messages.

---

**6. Write Tests (If Required)**

Many projects require tests for new features. For example, **Swarmauri** mandates test coverage for every component.

```python
# Example test for a new feature
def test_new_feature():
    result = my_function(input="test")
    assert result == "expected_output"
```

üìâ _Pain avoided_: Debugging failing tests now beats cryptic errors in code review later.

---

**7. Push to Your Fork**

Upload your branch to GitHub:

```bash
git push origin fix/typo-in-docs
```

---

**8. Open a Pull Request (PR)**

- Go to your fork‚Äôs GitHub page.
- Click **‚ÄúCompare & Pull Request‚Äù** next to your pushed branch.
- Fill in the PR template:
  - **Title**: ‚ÄúFix typo in quickstart guide‚Äù
  - **Description**: Explain _what_ you changed, _why_, and link related issues (e.g., ‚ÄúCloses #123‚Äù).
  - **Checklist**: Confirm tests pass and documentation is updated.

üéØ _Pro move_: Tag a maintainer (e.g., ‚Äú@janedoe PTAL‚Äù) if the project‚Äôs guidelines allow it.

---

**9. Respond to Feedback**

Maintainers might request changes. Update your code, push to the same branch, and the PR auto-updates!

```bash
git add .
git commit -m "Address review feedback"
git push origin fix/typo-in-docs
```

---

**After the PR is Merged**

- üéâ **Celebrate!** You‚Äôve just contributed to open source.
- üîÑ **Sync your fork**: Pull updates from the original repo to keep your fork fresh.
- üå± **Stay involved**: Tackle another issue or help triage bugs.

---

:::success{title="You Did It!"}  
Your first PR might feel like climbing Everest, but soon you will be sprinting up these hills.

## How to Stand Out as a Contributor and Build Your Brand

1. **Solve Meaningful Problems**:  
   Focus on high-impact issues (bugs, feature requests) that users care about. Quality > quantity.

2. **Communicate Clearly**:  
   Write detailed PR descriptions, link related issues, and respond promptly to feedback. If possible, use screenshots/GIFs to explain UI changes.

3. **Document Everything**:  
   Fix typos, improve tutorials, or add code comments. Great docs are rare; your work will get noticed.

4. **Share Your Work**:  
   Post about contributions on LinkedIn/Twitter, tag the project, and link to your PR. Example:  
   _‚ÄúJust added [feature] to @PyTorch! Learned [X], check out the PR üëá‚Äù_

5. **Help Others**:  
   Answer questions in Discussions/forums. Mentoring newcomers builds trust and visibility.

6. **Stay Consistent**:  
   Regular contributions > one-off PRs. Even small fixes keep you on maintainers‚Äô radar.

---

:::tip{title="Final Thoughts"}  
Contributing to open-source AI/ML isn‚Äôt just about code. It‚Äôs about **learning**, **collaborating**, and **shaping the future** of technology. Whether you‚Äôre fixing a typo in PyTorch‚Äôs docs or building a new feature for LangChain, every contribution matters.

**Your journey starts now**:

1. Pick a project from this list that excites you.
2. Fork it, tackle a `good-first-issue`, and submit that PR.
3. Share your wins (and lessons) with the community.

The open-source world thrives on curiosity and courage.

_P.S. Tag us when you land your first contribution, we would love to celebrate with youü§ù_  
:::


